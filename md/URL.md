### <font color=#0099ff >浏览器中输入URL并回车后</font>


#### <font color=#0099ff >1、解析URL</font>
![图片](/img/url_01.jpg)


#### <font color=#0099ff >2、DNS解析</font>

DNS解析（域名解析），DNS实际上是一个域名和IP对应的数据库。

IP地址往都难以记住，但机器间互相只认IP地址，于是人们发明了域名，让域名与IP地址之间一一对应，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。

<font color=red>可以在浏览器中输入IP地址浏览网站，也可以输入域名查询网站，虽然得出的内容是一样的但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。</font>

<br/>
在进行DNS解析时，会经历以下步骤：

查询浏览器缓存（浏览器会缓存之前拿到的DNS 2-30分钟时间），如果没有找到，

检查系统缓存，检查hosts文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了。没有找到的话，需要

检查路由器缓存，路由器有自己的DNS缓存，可能就包括了这在查询的内容；如果没有，要

查询ISP DNS 缓存：ISP服务商DNS缓存（本地服务器缓存）那里可能有相关的内容，如果还不行的话，需要，

递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索哦对应目标域名的IP。
![图片](/img/url_02.png)

通过以上的查找，就可以获取到域名对应的IP了。接下来就是向该IP地址定位的HTTP服务器发起TCP连接。


#### <font color=#0099ff >3、浏览器与网站建立TCP连接（三次握手）</font> (SYN ACK)

第一次握手：客户端向服务器端发送请求（SYN=1） 等待服务器确认；

第二次握手：服务器收到请求并确认，回复一个指令（SYN=1，ACK=1）；

第三次握手：客户端收到服务器的回复指令并返回确认（ACK=1）。
![图片](/img/url_03.png)

<p color=red>为什么是三次握手，两次不行吗？</p>

![图片](/img/url_04.png)

#### <font color=#0099ff >4、请求和传输数据</font>（感觉这块讲的不好@todo）

![图片](/img/url_07.png)

注意响应头中有一个：Set-Cookie:"PHPSESSID=c882giens9f7d3oglcakhrl994; path=/"，说明浏览器中没有关于这个网站的cookie信息。

![图片](/img/url_08.png)

可以看到，请求头中包含了这个cookie信息，

Cookie:"PHPSESSID=c882giens9f7d3oglcakhrl994; CNZZDATA1253283365=1870471808-1473694656-%7C1473694656"

cookie可以用来保存一些有用的信息：Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。

通过这种GET请求，和服务器的响应。可以将服务器上的目标文件传输到浏览器进行渲染。

#### <font color=#0099ff >5、断开连接（四次挥手）</font> (FIN ACK)
![图片](/img/url_05.png)


<p color=red>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p>

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，收到对方的FIN报文时，

仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，

再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

不应该是为了防止B发送的FIN=1的包的丢失，因为如果A没有收到来自B的释放连接请求，是不会进入TIME-WAIT状态的。

所以正确的解释是：A发送的确认释放连接信息B没有收到，这时候B会再次发送一个FIN=1的释放连接请求，而这个时候A还处于TIME-WAIT，所以可以再次发送确认信息


![图片](/img/url_06.gif)

#### <font color=#0099ff >6、浏览器渲染页面</font>

客户端拿到服务器端传输来的文件，找到HTML和MIME文件，通过MIME文件，浏览器知道要用页面渲染引擎来处理HTML文件。

* a.浏览器会解析html源码，然后创建一个 DOM树。 在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。

* b.浏览器解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM。<br/>首先会忽略非法的CSS代码，之后按照浏览器默认设置——用户设置——外链样式——内联样式——HTML中的style样式顺序进行渲染。

* c.利用DOM和CSSOM构建一个渲染树（rendering tree）。<br/>渲染树和DOM树有点像，但是是有区别的。<br/>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。<br/>而且一大段文本中的每一个行在渲染树中都是独立的一个节点。<br/>渲染树中的每一个节点都存储有对应的css属性。

* d.浏览器就根据渲染树直接把页面绘制到屏幕上。
