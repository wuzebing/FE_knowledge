#### <font color=#0099ff >函数柯里化</font>

##### <font color=#0099ff >什么是函数柯里化</font>

javascript忍者中说：在一个函数中首先填充几个参数(然后再返回一个新函数)的技术称为柯里化(Currying)。听起来跟bind的作用是一样的，其实bind也可以采用这种思想来实现（至于bind原本是怎么实现的，我不清楚，控制台输出Function.prototype.bind，输出是[native code]，看不到，不清楚内部原理）。

在很多文章中写到：柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。

举个不是很恰当的例子，有一个厨师，要做饭，但是餐馆的小儿没有把菜买齐，这样，小儿买一份原料，放在厨师厨房，再买一份，放在厨师厨房，等买齐了，叫厨师过来，好了，原料齐了，可以做饭了。这个时候，厨师利用原料，把饭做好。厨师就像一个函数，他有自己的功能（做饭），但是参数（原料）不齐，每次执行这个函数，在参数不齐的情况下，只能返回一个新的函数，这个新的函数已经内置了之前的参数，当参数齐了之后完成他本身的功能。

例如

要实现一个这样的加法函数，使得：

```
add(1,2,3)(1)(2)(3)(4,5,6)(7,8)() === 42
```

首先，可以看到，这个函数，只有当参数为空的时候，才执行之前所有数值的加法，这样的嵌套可以无限进行，当有参数的时候，add(1,2,3)，这个时候的返回值应该是一个函数，这个函数存储了1,2,3但是没有执行加法（执行了也行，此处假设就不执行，只是起到保存参数的作用），这样，继续执行add(1,2,3)(2)()

就能输出1+2+3+2=8。

要实现这样的一个函数，首先，返回值在参数不为空的时候必定返回一个函数，该函数还保存了之前的参数，这就需要用到闭包。

最终的实现如下：

```
// add 函数柯里化
function add(){
    //建立args,利用闭包特性，不断保存arguments
    var args = [].slice.call(arguments);
       //方法一，新建_add函数实现柯里化
    var _add = function(){
        if(arguments.length === 0){
            //参数为空，对args执行加法
            return args.reduce(function(a,b){return a+b});
        }else {
            //否则，保存参数到args，返回一个函数
            [].push.apply(args,arguments);
            return _add;
        }
    }
    //返回_add函数
    return _add;
    
    // //方法二，使用arguments.callee实现柯里化
    // return function () {
  //       if (arguments.length === 0) {
  //           return args.reduce(function(a,b){return a+b});
  //       }
  //       Array.prototype.push.apply(args, arguments);
  //       return arguments.callee;
  //   }
}
```

实现的原理主要是：


* 1、闭包保存args变量，存储之前的参数
* 2、新建一个_add函数，参数的长度为0，就执行加法，否则，存储参数到args，然后返回函数自身（可以选择匿名函数，返回arguments.callee即可，意思相同，见代码中注释掉的部分，但是在严格模式下不能使用，所以还是使用方法一比较稳妥）。